package main

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"
	"strings"

	"github.com/golang/glog"
	"github.com/golang/protobuf/proto"
	desc "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/descriptor"
	gen "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-grpc-gateway/generator"
	"path"
)

type generator struct {
	reg       *descriptor.Registry
	mapValues []string
}

// New returns a new generator which generates grpc gateway files.
func New(reg *descriptor.Registry) gen.Generator {
	return &generator{reg: reg, mapValues: []string{}}
}

func (g *generator) getRawTypeName(file *descriptor.File, a string) string {
	m, err := g.reg.LookupMsg(file.GetPackage(), a)
	isMessage := false
	isEnum := false
	if err == nil {
		isMessage = true
	}
	e, err := g.reg.LookupEnum(file.GetPackage(), a)
	if err == nil {
		isEnum = true
	}
	var mf *descriptor.File
	ss := strings.Split(a, ".")
	if isMessage {
		mf = m.File
	} else if isEnum {
		mf = e.File
	} else {
		panic(fmt.Errorf("%s is not message or enum", a))
		return ""
	}
	if mf.GetName() == file.GetName() {
		return ss[len(ss)-1]
	} else {
		fname := mf.GetName()
		fbase := strings.TrimSuffix(fname, filepath.Ext(fname))
		return mf.GetPackage() + "_" + fbase + "." + ss[len(ss)-1]
	}
}

func (g *generator) getTypeName(t desc.FieldDescriptorProto_Type, field *desc.FieldDescriptorProto, file *descriptor.File) string {
	switch t {
	case desc.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case desc.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case desc.FieldDescriptorProto_TYPE_FIXED32, desc.FieldDescriptorProto_TYPE_FIXED64, desc.FieldDescriptorProto_TYPE_DOUBLE:
		return "number"
	case desc.FieldDescriptorProto_TYPE_FLOAT, desc.FieldDescriptorProto_TYPE_INT32, desc.FieldDescriptorProto_TYPE_INT64:
		return "number"
	case desc.FieldDescriptorProto_TYPE_UINT32, desc.FieldDescriptorProto_TYPE_UINT64:
		return "number"
	case desc.FieldDescriptorProto_TYPE_ENUM:
		return g.getRawTypeName(file, field.GetTypeName())
	case desc.FieldDescriptorProto_TYPE_MESSAGE:
		return g.getRawTypeName(file, field.GetTypeName())
	default:
		return "any"
	}
}

func (g *generator) isMap(field *desc.FieldDescriptorProto) bool {
	if field.GetLabel() == desc.FieldDescriptorProto_LABEL_REPEATED && field.GetType() == desc.FieldDescriptorProto_TYPE_MESSAGE {
		t := field.GetTypeName()
		for _, v := range g.mapValues {
			if t == v {
				return true
			}
		}
	}
	return false
}

func (g *generator) printMessageField(w io.Writer, field *desc.FieldDescriptorProto, file *descriptor.File) {
	if g.isMap(field) {
		fmt.Fprintf(w, "    %s: any;\n", field.GetJsonName())
	} else if field.GetLabel() == desc.FieldDescriptorProto_LABEL_REPEATED {
		fmt.Fprintf(w, "    %s: %s[];\n", field.GetJsonName(), g.getTypeName(field.GetType(), field, file))
	} else {
		fmt.Fprintf(w, "    %s: %s;\n", field.GetJsonName(), g.getTypeName(field.GetType(), field, file))
	}
}

func ToJsonName(pre string) string {
	if len(pre) == 0 {
		return ""
	}
	word := pre[:1]
	ss := make([]string, 0)
	for i := 1; i < len(pre); i++ {
		letter := pre[i : i+1]
		if word != "" && strings.ToUpper(letter) == letter {
			ss = append(ss, word)
			if letter != "_" && letter != "-" {
				word = letter
			} else {
				word = ""
			}
		} else {
			word += letter
		}
	}
	ss = append(ss, word)
	for i, v := range ss {
		if i != 0 {
			ss[i] = strings.Title(v)
		} else {
			ss[0] = strings.ToLower(ss[0])
		}
	}
	return strings.Join(ss, "")
}

func ToParamName(pre string) string {
	ss := strings.Split(pre, ".")
	return ToJsonName(ss[len(ss)-1])
}

func (g *generator) generate(file *descriptor.File) (string, error) {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, `// Code generated by protoc-gen-angular.
// DO NOT EDIT!
`)
	if len(file.Services) > 0 {
		fmt.Fprintln(&buf, `
import {Injectable} from '@angular/core';
import {Http, Response, RequestOptions, RequestMethod, Headers} from "@angular/http";
import {Observable} from "rxjs/Observable";
import {AuthService} from "./auth.service"`)
	}
	for _, d := range file.GetDependency() {
		if d == "google/api/annotations.proto" || d == "github.com/gogo/protobuf/gogoproto/gogo.proto" {
			continue
		}
		p := path.Base(d)
		p = strings.TrimSuffix(p, filepath.Ext(p))
		ff, fe := g.reg.LookupFile(d)
		if fe != nil {
			return "", fe
		}
		fbase := strings.TrimSuffix(ff.GetName(), filepath.Ext(ff.GetName()))
		pn := ff.GetPackage() + "_" + fbase
		fmt.Fprintf(&buf, "import * as %s from \"./%s.pb\";\n", pn, p)
	}

	fmt.Fprintln(&buf, "")

	pack := file.GetPackage()
	for _, m := range file.Messages {
		mesName := fmt.Sprintf(".%s.%s", pack, m.GetName())
		for _, n := range m.GetNestedType() {
			if n.GetOptions().GetMapEntry() {
				g.mapValues = append(g.mapValues, fmt.Sprintf("%s.%s", mesName, n.GetName()))
			}
		}
	}

	for _, e := range file.Enums {
		fmt.Fprintf(&buf, "export declare enum %s {\n", e.GetName())
		for _, v := range e.GetValue() {
			//    APP = <any> "APP",
			fmt.Fprintf(&buf, "    %s = <any> \"%s\",\n", v.GetName(), v.GetName())
		}
		fmt.Fprintln(&buf, "}")
	}

	for _, m := range file.Messages {
		//	glog.Errorf("message %v", m)
		if m.GetOptions().GetMapEntry() {
			continue
		}
		fmt.Fprintf(&buf, "export class %s {\n", m.GetName())
		for _, f := range m.GetField() {
			g.printMessageField(&buf, f, file)
			//	glog.Errorf("  field %s name '%s':'%v':'%s'", f.GetJsonName(), f.GetName(), f.GetType(), f.GetTypeName())
		}
		fmt.Fprintln(&buf, "}")
	}

	for _, s := range file.Services {
		fmt.Fprintf(&buf, `
@Injectable()
export class %sService {
  host: string;

  constructor(private http: Http, private auth:AuthService) {
    this.host = "http://localhost:18866";
  }

  private _extractData(res: Response) {
    let body = res.json();
    return body || {};
  }

  private _handleError(error: any, cauth: Observable<void>) {
    let errMsg = (error.message) ? error.message :
      (error.status ? error.status+" - "+error.statusText : 'Server error')
		console.error(errMsg);
		return Observable.throw(errMsg);
  }
`, s.GetName())
		for _, m := range s.Methods {
			if len(m.Bindings) == 0 {
				continue
			}
			b := m.Bindings[0]
			method := b.HTTPMethod[:1] + strings.ToLower(b.HTTPMethod[1:])
			pack := *file.Package
			allFieldsUsedForUrl := false
			var inMessage *descriptor.Message
			for _, mes := range file.Messages {
				mName := fmt.Sprintf(".%s.%s", pack, mes.GetName())
				if mName == m.GetInputType() {
					allFieldsUsedForUrl = len(mes.Fields) == len(b.PathTmpl.Fields)
					inMessage = mes
					break
				}
			}
			inputName := ToParamName(m.GetInputType())
			body := fmt.Sprintf("body: JSON.stringify(%s),", inputName)
			if method == "Get" || method == "Delete" {
				body = ""
			}
			if allFieldsUsedForUrl && (method == "Post" || method == "Put") {
				body = "body: \"{}\","
			}
			inputType := fmt.Sprintf("%s: %s", inputName, g.getRawTypeName(file, m.GetInputType()))
			if allFieldsUsedForUrl {
				inputType = ""
				for _, f := range inMessage.GetField() {
					inputType = fmt.Sprintf("%s,%s:%s", inputType, f.GetJsonName(), g.getTypeName(f.GetType(), f, file))
				}
				inputType = inputType[1:]
			}
			temp := b.PathTmpl.Template
			for _, r := range b.PathTmpl.Fields {
				if allFieldsUsedForUrl {
					temp = strings.Replace(temp, fmt.Sprintf("{%s}", r), fmt.Sprintf("${%s}", ToJsonName(r)), -1)
				} else {
					temp = strings.Replace(temp, fmt.Sprintf("{%s}", r), fmt.Sprintf("${%s.%s}", inputName, ToJsonName(r)), -1)
				}
			}
			url := fmt.Sprintf("`${this.host}%s`", temp)

			fmt.Fprintf(&buf, `
  %s(%s): Observable<%s> {
    let _headers = new Headers();
    this.auth.setAuthToHeaders(_headers);
    let _args = new RequestOptions({
      method: RequestMethod.%s,
      headers: _headers,
      %s
    });
    return this.http.request(%s, _args)
      .map(this._extractData)
      .catch(this._handleError);
  }
`, ToJsonName(m.GetName()), inputType, g.getRawTypeName(file, m.GetOutputType()), method, body, url)
		}
		fmt.Fprintln(&buf, "}")
	}
	return buf.String(), nil
}
func (g *generator) Generate(targets []*descriptor.File) ([]*plugin.CodeGeneratorResponse_File, error) {
	var files []*plugin.CodeGeneratorResponse_File
	for _, file := range targets {
		str, err := g.generate(file)
		if err != nil {
			return nil, err
		}
		name := file.GetName()
		ext := filepath.Ext(name)
		base := strings.TrimSuffix(name, ext)
		output := fmt.Sprintf("%s.pb.ts", base)
		files = append(files, &plugin.CodeGeneratorResponse_File{
			Name:    proto.String(output),
			Content: proto.String(str),
		})
		glog.V(1).Infof("Will emit %s", output)
	}

	return files, nil
}
